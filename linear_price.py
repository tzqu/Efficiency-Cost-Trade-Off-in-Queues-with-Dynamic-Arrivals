# -*- coding: utf-8 -*-
"""Linear Price.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yyzJOO816LBT2TBNqqE8g_ahhDwre6Sp
"""

# F(x) = 5x - x**2, so p(x) = 5 - x

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Constants
F_dd_1 = -2
mu = 1
max_time = int(1e8)
steady_start = max_time / 2
epsilons = np.array([0.001, 0.004, 0.007, 0.01, 0.025, 0.04, 0.055, 0.07, 0.085, 0.1])

def simulate_policy(epsilon, policy_type):
    np.random.seed(42)
    state = 0
    current_time = 0
    total_revenue = 0
    weighted_q_time = 0
    arrivals = 0

    if policy_type == 'two-price':
        lambda_1 = 1 + np.sqrt(epsilon / -F_dd_1) * np.sqrt(np.log(1 / epsilon))
        lambda_2 = 1 - np.sqrt(epsilon / -F_dd_1) / np.sqrt(np.log(1 / epsilon))
        tau = int(np.floor(0.5 * np.sqrt(-F_dd_1 / epsilon) * np.sqrt(np.log(1 / epsilon))))

        def get_lambda(q):
            return lambda_1 if q < tau else lambda_2

    elif policy_type == 'dynamic':
        B = int(np.floor(np.sqrt(-6 * F_dd_1 / epsilon)))

        def get_lambda(q):
            if q < B:
                return ((q + 2) / (q + 1))**2
            elif q < 2 * B:
                return ((2 * B - q) / (2 * B - q + 1))**2
            else:
                return 0

    def price(lam):
        return 5 - lam

    while current_time < max_time:
        lam = get_lambda(state)
        rate = lam + mu if state > 0 else lam
        if rate == 0:
            break
        dt = np.random.exponential(1 / rate)
        next_time = current_time + dt

        # Decide event type
        if state == 0:
            event_type = 'arrival'
        else:
            event_type = 'arrival' if np.random.rand() < lam / rate else 'service'

        # Revenue and queue tracking during steady-state
        if next_time > steady_start:
            time_contrib = max(0, next_time - max(current_time, steady_start))
            weighted_q_time += state * time_contrib
            if event_type == 'arrival':
                total_revenue += price(lam)
                arrivals += 1

        if event_type == 'arrival':
            state += 1
        elif event_type == 'service' and state > 0:
            state -= 1

        current_time = next_time

    duration = max_time - steady_start
    return total_revenue / duration, weighted_q_time / duration

# Run experiments
data = {'epsilon': [], 'policy': [], 'Revenue Gap (%)': [], 'E[q]': []}
for eps in epsilons:
    for policy in ['two-price', 'dynamic']:
        rev, qlen = simulate_policy(eps, policy)
        gap_percent = (4 - rev) / 4 * 100
        data['epsilon'].append(eps)
        data['policy'].append(policy)
        data['Revenue Gap (%)'].append(gap_percent)
        data['E[q]'].append(qlen)


df = pd.DataFrame(data)

# Plotting
plt.figure(figsize=(10, 6))
for policy in ['two-price', 'dynamic']:
    subset = df[df['policy'] == policy]
    plt.plot(subset['Revenue Gap (%)'], subset['E[q]'], marker='o', label=policy)

plt.xlabel("Revenue Gap to Optimal (%)")
plt.ylabel("Expected Queue Length")
plt.title(f"Tradeoff between Revenue and Queue Length (T = {max_time:.0e})")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# Display DataFrame
print(df.to_string(index=False))